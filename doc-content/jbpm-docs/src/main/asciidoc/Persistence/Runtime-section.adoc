= Process Instance State


jBPM allows the persistent storage of certain information.
This chapter describes these different types of persistence and how to configure them.
An example of the information stored is the process runtime state.
Storing the process runtime state is necessary in order to be able to continue execution of a process instance at any point, if something goes wrong.
Also, the process definitions themselves, and the history information (logs of current and previous process states) can also be persisted.

jBPM 允许特定信息永久保存。这一章描述不同类型的持久化和如何配置他们。 一个例子展示流程运行时状态如何保存信息。保存流程运行时状态非常必要，这使得在错误发生后，可以继续从错误发生的地方继续执行流程。
并且，流程定义，历史信息（当前或者之前的流程状态日志）都可以被持久化。

== Runtime State


Whenever a process is started, a process instance is created, which represents the execution of the process in that specific context.
For example, when executing a process that specifies how to process a sales order, one process instance is created for each sales request.
The process instance represents the current execution state in that specific context, and contains all the information related to that process instance.
Note that it only contains the (minimal) runtime state that is needed to continue the execution of that process instance at some later time, but it does not include information about the history of that process instance if that information is no longer needed in the process instance.

当流程开始，流程实例被创建，这代表着在特定的上下文环境中流程的执行状态。比如当执行一个流程决定销售订单，每一个销售请求都创建了一个流程实例。
流程实例代表当前执行状态，包含相关流程实例的所有信息。
注意，这仅仅包括可以支持流程再之后继续执行的最小运行时状态，不会包含流程的历史信息

The runtime state of an executing process can be made persistent, for example, in a database.
This allows to restore the state of execution of all running processes in case of unexpected failure, or to temporarily remove running instances from memory and restore them at some later time.
jBPM allows you to plug in different persistence strategies.
By default, if you do not configure the {PROCESS_ENGINE} otherwise, process instances are not made persistent.

执行中的流程的运行时状态可以被持久化，比如放到数据库中。这使得可以在失败之后恢复所有的流程，或者允许暂时移除运行时实例，并且在之后继续执行。
jBPM 允许插入不同的持久化策略。
默认，如果没有配置 {PROCESS_ENGINE} ，流程实例不会持久化。

If you configure the {PROCESS_ENGINE} to use persistence, it will automatically store the runtime state into the database.
You do not have to trigger persistence yourself, the {PROCESS_ENGINE} will take care of this when persistence is enabled.
Whenever you invoke the {PROCESS_ENGINE}, it will make sure that any changes are stored at the end of that invocation, at so-called safe points.
Whenever something goes wrong and you restore the {PROCESS_ENGINE} from the database, you also should not reload the process instances and trigger them manually to resume execution, as process instances will automatically resume execution if they are triggered, like for example by a timer expiring, the completion of a task that was  requested by that process instance, or a signal being sent to the process instance.
The {PROCESS_ENGINE} will automatically reload process instances on demand.

当配置了 {PROCESS_ENGINE} 持久化，系统会自动将运行时状态保存到数据库。
你不需要关心合适触发持久化，{PROCESS_ENGINE} 会在合适的时候自动处理。
无论何时调用 {PROCESS_ENGINE}，他会保证任何修改都会在调用结束时被保存，所谓的 safe points。
一旦有错误发生，从数据库中恢复 {PROCESS_ENGINE} ，你不需要手动重新加载流程实例，并且触发继续执行，流程实例会自动在触发后恢复执行。

The runtime persistence data should in general be considered internal, meaning that you probably should not try to access these database tables directly and especially not try to modify these directly (as changing the runtime state of process instances without the {PROCESS_ENGINE} knowing might have unexpected side-effects).  In most cases where information about the current execution state of process instances is required, the use of a history log is mostly recommended (see below).  In some cases, it might still be useful to for example query the internal database tables directly, but you should only do this if you know what you are doing.o

运行时持久化内容应该被认为是内部的，这意味着你不应该直接从数据库中访问这些数据，尤其不应该直接修改，修改这些数据而不告知 {PROCESS_ENGINE} 可能造成意想不到的负面作用。在大部分情况下当前流程状态被需要时，推荐使用历史日志。在一些特殊情况下，直接查询内部数据表也是有用的，但是前提是你需要知道你正在做什么。

=== Binary Persistence


jBPM uses a binary persistence mechanism, otherwise known as marshalling, which converts the state of the process instance into a binary dataset.
When you use persistence with jBPM, this  mechanism is used to save or retrieve the process instance state  from the database.
The same mechanism is also applied to the  session state and any work item states.

When the process instance state is persisted, two things happen:

* First, the process instance information is transformed  into a binary blob. For performance reasons, a custom serialization  mechanism is used and not normal Java serialization.
* This blob is then stored, alongside other metadata about  this process instance. This metadata includes, among other things,  the process instance id, process id, and the process start date.

Apart from the process instance state, the session itself can  also store some state, such as the state of timer jobs, or the session  data that any business rules would be evaluated over.
This session state is stored separately as a binary blob, along with  the id of the session and some metadata.
You can always restore session  state by reloading the session with the given id.
The session id can  be retrieved using ``ksession.getId()``.

Note that the process instance binary datasets are usually  relatively small, as they only contain the minimal execution state  of the process instance.
For a simple process instance, this usually  contains one or a few node instances, i.e., any node that is currently  executing, and any existing variable values.

As a result of jBPM using marshalling, the data model is both  simple and small.

.jBPM data model
image::Persistence/jbpm_schema_doc.png[]

The `sessioninfo` entity contains the state of the  (knowledge) session in which the jBPM process instance is running.

.SessionInfo
[cols="1,1,1", options="header"]
|===
| Field
| Description
| Nullable

|``id``
|The primary key.
|NOT NULL

|``lastmodificationdate``
|The last time that the entity was saved to the database
|

|``rulesbytearray``
|The binary dataset containing the state of the session
|NOT NULL

|``startdate``
|The start time of the session
|

|``optlock``
|The version field that serves as its optimistic lock value
|
|===


The `processinstanceinfo` entity contains the state  of the jBPM process instance.

.ProcessInstanceInfo
[cols="1,1,1", options="header"]
|===
| Field
| Description
| Nullable

|``instanceid``
|The primary key
|NOT NULL

|``lastmodificationdate``
|The last time that the entity was saved to the database
|

|``lastreaddate``
|The last time that the entity was retrieved (read) from the database
|

|``processid``
|The name (id) of the process
|

|``processinstancebytearray``
|This is the binary dataset containing the state of the process instance
|NOT NULL

|``startdate``
|The start time of the process
|

|``state``
|An integer representing the state of the process instance
|NOT NULL

|``optlock``
|The version field that serves as its optimistic lock value
|
|===


The `eventtypes` entity contains information about events that a process instance will undergo or has undergone.

.EventTypes
[cols="1,1,1", options="header"]
|===
| Field
| Description
| Nullable

|``instanceid``
|This references the `processinstanceinfo` primary key and there is a foreign key constraint on
 this column.
|NOT NULL

|``eventTypes``
|A text field related to an event that the process has undergone.
|
|===


The `workiteminfo` entity contains the state of a work item.

.WorkItemInfo
[cols="1,1,1", options="header"]
|===
| Field
| Description
| Nullable

|``workitemid``
|The primary key
|NOT NULL

|``creationDate``
|The creation date of the work item
|

|``name``
|The name of the work item
|

|``processinstanceid``
|The (primary key) id of the process: there is no foreign key constraint on this field.
|NOT NULL

|``state``
|An integer representing the state of the work item
|NOT NULL

|``optlock``
|The version field that serves as its optimistic lock value
|

|``workitembytearay``
|This is the binary dataset containing the state of the work item
|NOT NULL
|===


The `CorrelationKeyInfo` entity contains information about correlation keys assigned to given process instance - loose relationship as this table is considered optional used only when correlation capabilities are required.

.CorrelationKeyInfo
[cols="1,1,1", options="header"]
|===
| Field
| Description
| Nullable

|``keyid``
|The primary key
|NOT NULL

|``name``
|assigned name of the correlation key
|

|``processinstanceid``
|The id of the process instance which is assigned to this correlation key
|NOT NULL

|``optlock``
|The version field that serves as its optimistic lock value
|
|===


The `CorrelationPropertyInfo` entity contains information about correlation properties for given correlation key that is assigned to given process instance.

.CorrelationPropertyInfo
[cols="1,1,1", options="header"]
|===
| Field
| Description
| Nullable

|``propertyid``
|The primary key
|NOT NULL

|``name``
|The name of the property
|

|``value``
|The value of the property
|NOT NULL

|``optlock``
|The version field that serves as its optimistic lock value
|

|``correlationKey-keyid``
|Foregin key to map to correlation key
|NOT NULL
|===


The `ContextMappingInfo` entity contains information about contextual information mapped to ksession.
This is an internal part of RuntimeManager and can be considered optional when RuntimeManager is not used.

.ContextMappingInfo
[cols="1,1,1", options="header"]
|===
| Field
| Description
| Nullable

|``mappingid``
|The primary key
|NOT NULL

|``context_id``
|Identifier of the context
|NOT NULL

|``ksession_id``
|Identifier of the ksession mapped to this context
|NOT NULL

|``optlock``
|The version field that serves as its optimistic lock value
|
|===

=== Safe Points

The state of a process instance is stored at so-called "safe points" during the execution of the {PROCESS_ENGINE}.
Whenever a process instance is executing (for example when it started or continuing from a previous wait state, the {PROCESS_ENGINE} executes the process instance until no more actions can be performed (meaning that the process instance either has completed (or was aborted), or that it has reached a wait state in all of its parallel paths). At that point, the {PROCESS_ENGINE} has reached the next safe state, and the state of the process instance (and all other process instances that might have been affected) is stored persistently.
