[id='executable-model-con_{context}']

= Executable rule models

Executable rule models are embeddable models that provide a Java-based representation of a rule set for execution at build time. The executable model is a more efficient alternative to the standard asset packaging in {PRODUCT} and enables KIE containers and KIE bases to be created more quickly, especially when you have large lists of DRL (Drools Rule Language) files and other {PRODUCT} assets. The model is low level and enables you to provide all necessary execution information, such as the lambda expressions for the index evaluation.

Executable rule models provide the following specific advantages for your projects:

可执行规则模型为您的项目提供以下优势：

* *Compile time:* Traditionally, a packaged {PRODUCT} project (KJAR) contains a list of DRL files and other {PRODUCT} artifacts that define the rule base together with some pre-generated classes implementing the constraints and the consequences. Those DRL files must be parsed and compiled when the KJAR is downloaded from the Maven repository and installed in a KIE container. This process can be slow, especially for large rule sets. With an executable model, you can package within the project KJAR the Java classes
that implement the executable model of the project rule base and re-create the KIE container and its KIE bases out of it in a much faster way. In Maven projects, you use the `kie-maven-plugin` to automatically generate the executable model sources from the DRL files during the compilation process.
* *Run time:* In an executable model, all constraints are defined as Java lambda expressions. The same lambda expressions are also used
for constraints evaluation, so you no longer need to use `mvel` expressions for interpreted evaluation nor the just-in-time (JIT) process to transform the `mvel`-based constraints into bytecode. This creates a quicker and more efficient run time.
* *Development time:* An executable model enables you to develop and experiment with new features of the {DECISION_ENGINE} without needing to encode elements directly in the DRL format or modify the DRL parser to support them.


* *编译时间* 习惯上，一个打包的 {PRODUCT} 项目（KJAR）包含一组 DRL 文件和其他 {PRODUCT} 的定义，包括一些预先定义的类，以及实现的约束和顺序。这些 DRL 文件
在从 Maven 仓库中下载并安装到 KIE 容器中时必须经过解析。而这个过程可能非常缓慢，尤其是大型规则集合。通过可执行的模型，you can package within the project KJAR the Java classes that implement the executable model of the project rule base and re-create the KIE container and its KIE bases out of it in a much faster way. 在 Maven 项目中，你可以使用 `kie-maven-plugin` 插件在编译时自动从 DRL 文件中产生可执行模型资源。
* *Run time* 在可执行模型中，所有约束都被定义为 Java lambda 表达式。同样的 lambda 表达式也被用在约束求值，所以你将不需要使用 `mvel` 表达式来解释求值，也不需要使用 just-in-time (JIT) 过程来将 `mvel` 约束转变成 bytecode. 这样可以在运行时更加快。
* *Development time* 可执行的模型使得开发者可以开发和测试新的 {DECISION_ENGINE} 的特性，而不需要直接编码 DRL 格式，或者修改 DRL 解析器来支持。

NOTE: For query definitions in executable rule models, you can use up to 10 arguments only.

ifdef::DROOLS[]
== Executable model domain-specific languages (DSLs)

One goal while designing the first iteration of the domain-specific language (DSL) for the executable model was to get rid of the notion of pattern and to consider a rule as a flow of expressions (constraints) and actions (consequences). For this reason we called it Flow DSL. Some examples of this DSL are available here.

在我们设计第一版可执行模型的 DSL （领域特定语言）时，我们的目标是去除 pattern 的概念，并且考虑a rule as a flow of expressions (constraints) and actions (consequences). 因为这个原因我们称它为 Flow DSL。下面是一些可用的 DSL 例子。

However after having implemented the Flow DSL it became clear that the decision of avoiding the explicit use of patterns obliged us to implement some extra logic that had both a complexity and a performance cost, since in order to properly re-create the data structures expected by the Drools compiler it is necessary to put together the patterns out of those apparently unrelated expressions.

但是在实现了 Flow DSL 之后，避免特定 patterns 的使用迫使我们实现一些额外的逻辑，这些额外的逻辑造成了一定的复杂性和性能损耗，为了重新创建 Drools 编译器期望的数据结构，将这些 patterns 放到一起变得必要。

For this reason it has been decided to reintroduce the patterns in a second DSL that we called Pattern DSL. This allowed to bypass that algorithm grouping expressions that has to fill an artificial semantic gap and that is also time consuming at run time. We believe that both DSLs are valid for different use cases and so we decided to keep and support both. In particular the Pattern DSL is safer and faster (even if more verbose) so this will be the DSL that will be automatically generated when creating a KJAR through the kie-maven-plugin. Conversely the Flow DSL is more succinct and closer to the way a user may want to programmatically define a rule in Java and we planned to make it even less verbose by generating in an automatic way through a post processor the parts of the model defining the indexing and property reactivity. In other words, we expect that the Pattern DSL will be written by machines and the Flow DSL eventually by humans.

因为这个原因，所以决定重新引入第二个 DSL 中的 patterns，我们称之为 Pattern DSL.

endif::DROOLS[]
